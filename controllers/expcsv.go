package controllers

import (
	"bufio"
	"fmt"
	"github.com/astaxie/beego"
	"time"
	//"github.com/astaxie/beego/logs"
	"github.com/gorilla/websocket"
	"github.com/juju/errgo/errors"
	"github.com/tgulacsi/goracle/examples/connect"
	//"github.com/tgulacsi/goracle/oracle"
	"io"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
	//"time"
)

type ExpCSVController struct {
	beego.Controller
}

func dump2(nls, dir, pdir, finame, dsn, qry, del, head, mode, batch string, ws *websocket.Conn) error {

	//os.Setenv("NLS_LANG", nls)
	//如果文件不存在则创建文件，如果文件已经存则覆写文件
	w, err := os.OpenFile(dir, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)
	if err != nil {
		fmt.Println("writer", err)
	}
	defer w.Close()

	cx, err := connect.GetRawConnection(dsn)
	if err != nil {
		return errors.Newf("error connecting to database: %s", err)
	}
	defer cx.Close()

	cu := cx.NewCursor()
	err = cu.Execute(qry, nil, nil)
	if err != nil {
		return errors.Newf("error executing %q: %s", qry, err)
	}
	defer cu.Close()

	columns, err := GetColumns(cu)
	if err != nil {
		return errors.Newf("error getting column converters: %s", err)
	}

	bw := bufio.NewWriterSize(w, 65536)
	defer bw.Flush()
	if head == "Y" {
		for i, col := range columns {
			if i > 0 {
				bw.WriteString(del)
			}
			bw.Write([]byte{'"'})
			bw.WriteString(col.Name)
			bw.Write([]byte{'"'})
		}
		bw.Write([]byte{'\n'})
	}

	n := 0                        // 记录数量
	fino := 1                     //文件编号
	filelist := make([]string, 0) //文件列表

	message := Message{
		Type: "output",
		Msg: "--- parameters info -----------------------------------------------" + "\n" +
			"- nls   : " + nls + "\n" +
			"- dir   : " + dir + "\n" +
			"- dsn   : " + dsn + "\n" +
			"- qry   : " + qry + "\n" +
			"- del   : " + del + "\n" +
			"- head  : " + head + "\n" +
			"- mode  : " + mode + "\n" +
			"- batch : " + batch + "\n" +
			"--- parameters info -----------------------------------------------" + "\n",
	}
	ws.WriteJSON(message)

	message = Message{
		Type: "output",
		Msg:  ">>> dump process begin",
	}
	ws.WriteJSON(message)

	rows, err := cu.FetchMany(1000)
	for err == nil && len(rows) > 0 {
		for _, row := range rows {
			for i, data := range row {
				if i > 0 {
					bw.WriteString(del)
				}
				if data == nil {
					continue
				}
				bw.WriteString(columns[i].String(data))
			}
			bw.Write([]byte{'\n'})
			n++

			batchInt, _ := strconv.Atoi(batch)
			if batchInt != 0 && n%batchInt == 0 {
				fmt.Println(n)
				bw.Flush()
				w.Close() //如果文件到达批量写入点，显式flush

				message = Message{
					Type: "output",
					Msg:  ">>> " + time.Now().String()[0:27] + " flush out " + strconv.Itoa(n) + " rows.",
				}
				ws.WriteJSON(message)

				w, err = os.OpenFile(dir+"."+strconv.Itoa(fino), os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)
				if err != nil {
					fmt.Println("writer", err)
				} else {
					filelist = append(filelist, dir+"."+strconv.Itoa(fino))
					fino++
				}
				defer w.Close()

				bw = bufio.NewWriterSize(w, 65536)
				defer bw.Flush()
			} else if batchInt == 0 && n%10000 == 0 {
				fmt.Println(n)
				bw.Flush()
				w.Close() //如果文件到达批量写入点，显式flush

				message = Message{
					Type: "output",
					Msg:  ">>> " + time.Now().String()[0:27] + " flush out " + strconv.Itoa(n) + " rows.",
				}
				ws.WriteJSON(message)

				w, err = os.OpenFile(dir, os.O_APPEND, os.ModePerm)
				if err != nil {
					fmt.Println("writer", err)
				}
				defer w.Close()

				bw = bufio.NewWriterSize(w, 65536)
				defer bw.Flush()
			}
		}
		rows, err = cu.FetchMany(1000)
	}
	message = Message{
		Type: "output",
		Msg:  ">>> " + time.Now().String()[0:27] + " flush out " + strconv.Itoa(n) + " rows.",
	}
	ws.WriteJSON(message)

	log.Printf("written %d rows.", n)
	if err != nil && err != io.EOF {
		return errors.Newf("error fetching rows from %s: %s", cu, err)
	}

	// 控制文件处理  导出的文本文件需要转换成 ansi/ascii 格式
	file, err := os.OpenFile(pdir+"\\sqlload.ctl", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)

	if err != nil {
		fmt.Println("创建控制文件失败", err)
	}
	defer file.Close()

	ctl :=
		`--
-- Generated by OCIULDR
--
OPTIONS(BINDSIZE=16777216,READSIZE=16777216,ERRORS=-1,ROWS=50000,PARALLEL=true)
LOAD DATA
infile '132000000\zzs_db_cgl.txt' "STR X'0a'" badfile '132000000\zzs_db_cgl.bad' discardfile '132000000\zzs_db_cgl.dis'
APPEND INTO TABLE zzs_db_cgl
FIELDS TERMINATED BY X'7e7e' TRAILING NULLCOLS 
(`

	fmt.Println(ctl)

	file.WriteString(`--` + "\r\n")
	file.WriteString(`-- Generated by X-SYSTEM` + "\r\n")
	file.WriteString(`--` + "\r\n")
	file.WriteString(`OPTIONS(BINDSIZE=16777216,READSIZE=16777216,ERRORS=-1,ROWS=50000,PARALLEL=true)` + "\r\n")
	file.WriteString(`LOAD DATA` + "\r\n")
	file.WriteString(`CHARACTERSET UTF8` + "\r\n")
	file.WriteString(`--LENGTH BYTE` + "\r\n")
	file.WriteString(`infile '` + finame + `' "STR X'0a'" badfile '` + finame + `.bad' discardfile '` + finame + `.dis'` + "\r\n")
	for i := 0; i < len(filelist); i++ {
		fmt.Println(filelist[i])
		fmt.Println(pdir)
		file.WriteString(`infile '` + SubStr(filelist[i], strings.LastIndex(filelist[i], `\`)+1, len(filelist[i])) + `' "STR X'0a'" badfile '` + SubStr(filelist[i], strings.LastIndex(filelist[i], `\`)+1, len(filelist[i])) + `.bad' discardfile '` + SubStr(filelist[i], strings.LastIndex(filelist[i], `\`)+1, len(filelist[i])) + `.dis'` + "\r\n")

	}
	file.WriteString(mode + ` INTO TABLE TABLE_NAME` + "\r\n")
	file.WriteString(`FIELDS TERMINATED BY X'7e7e' TRAILING NULLCOLS` + "\r\n")
	file.WriteString(`(` + "\r\n")

	desc, err := cu.GetDescription()
	for i, col := range desc {
		if i != len(desc)-1 {
			if col.Type == 156 { //date   DATE "YYYY-MM-DD HH24:MI:SS",
				fmt.Println(fmt.Sprintf("  %-32sDATE 'YYYY-MM-DD HH24:MI:SS',", col.Name))
				file.WriteString(fmt.Sprintf("  %-32sDATE 'YYYY-MM-DD HH24:MI:SS',\r\n", col.Name))
			} else {
				fmt.Printf("  %-32sCHAR(%d),\n", col.Name, col.InternalSize)
				file.WriteString(fmt.Sprintf("  %-32sCHAR(%d),\r\n", col.Name, col.InternalSize))
			}

		} else { //最后一个字段
			if col.Type == 156 {
				fmt.Println(fmt.Sprintf("  %-32sDATE 'YYYY-MM-DD HH24:MI:SS'", col.Name))
				file.WriteString(fmt.Sprintf("  %-32sDATE 'YYYY-MM-DD HH24:MI:SS'\r\n", col.Name))
			} else {
				fmt.Printf("  %-32sCHAR(%d)\n", col.Name, col.InternalSize)
				file.WriteString(fmt.Sprintf("  %-32sCHAR(%d)\r\n", col.Name, col.InternalSize))
			}
		}

	}
	fmt.Println(")")
	file.WriteString(")")

	// 批处理文件
	batFile, err := os.OpenFile(pdir+"\\sqlload.bat", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)
	if err != nil {
		fmt.Println("创建批处理文件失败", err)
	}
	defer batFile.Close()

	batFile.WriteString(":: unloading parameters: \r\n")
	batFile.WriteString(":: DSN :  " + dsn + "\r\n")
	batFile.WriteString(":: SQL :  " + qry + "\r\n")
	batFile.WriteString(":: DEL :  " + del + "\r\n")
	batFile.WriteString(":: HEAD:  " + head + "\r\n")
	batFile.WriteString(":: MODE:  " + mode + "\r\n")
	batFile.WriteString(":: BATCH:  " + batch + "\r\n")
	batFile.WriteString("rem chcp 936\r\n")
	batFile.WriteString("rem set NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK\r\n")
	batFile.WriteString("rem set NLS_LANG=AMERICAN AMERICA.US7ASCII\r\n")
	batFile.WriteString("sqlldr dzdz/oracle@tns_name control=sqlload.ctl log=sqlload.log\r\n")
	batFile.WriteString("pause")

	x := Message{
		Type: "completed",
		Msg:  ">>> dump process completed ---",
	}
	ws.WriteJSON(x)

	return nil
}

func (this *ExpCSVController) Get() {
	this.Data["title"] = "ExpCSV - X-SYSTEM"
	this.TplNames = "expcsv.html"

}

type Message struct {
	Type string `json:"type"`
	Msg  string `json:"msg"`
}

func (this *ExpCSVController) Ws() {
	nls := this.GetString("nls")
	dsn := this.GetString("dsn")
	qry := this.GetString("qry")
	del := this.GetString("del")
	head := this.GetString("head")
	batch := this.GetString("batch")
	mode := this.GetString("mode")
	dir := this.GetString("dir")

	fmt.Println("nls-----------", nls)
	fmt.Println("dsn-----------", dsn)
	fmt.Println("qry-----------", qry)
	fmt.Println("del-----------", del)
	fmt.Println("head-----------", head)
	fmt.Println("batch-----------", batch)
	fmt.Println("mode-----------", mode)
	fmt.Println("dir-----------", dir)

	this.TplNames = "_4_dummy.tpl"

	fmt.Println()
	fmt.Println("*******************************hello world!")
	fmt.Println()

	// Upgrade from http request to WebSocket.
	ws, err := websocket.Upgrade(this.Ctx.ResponseWriter, this.Ctx.Request, nil, 1024, 1024)
	defer ws.Close()
	if _, ok := err.(websocket.HandshakeError); ok {
		http.Error(this.Ctx.ResponseWriter, "Not a websocket handshake", 400)
		return
	} else if err != nil {
		beego.Error("Cannot setup WebSocket connection:", err)
		return
	}

	//--------------------------------------------------------------

	//设置默认分隔符 ≡
	if del == "" {
		del = "~~" //使用 7F 容易在导入的时候产生bad 文件
	}

	last := strings.LastIndex(dir, `\`)
	pdir := SubStr(dir, 0, last) //获取父目录
	finame := SubStr(dir, last+1, len(dir))
	/*
		this.Ctx.WriteString(`<table border="1">
								<tr>
								<td> nls </td>
								<td>` + nls + `</td>
								</tr>
								<tr>
								<td> batch </td>
								<td>` + batch + `</td>
								</tr>
								<tr>
								<td> mode </td>
								<td>` + mode + `</td>
								</tr>
								<tr>
								<td> dsn </td>
								<td>` + dsn + `</td>
								</tr>
								<tr>
								<td> qry </td>
								<td>` + qry + `</td>
								</tr>
								<tr>
								<td> del </td>
								<td>` + del + `</td>
								</tr>
								<tr>
								<td> dir </td>
								<td>` + dir + `</td>
								</tr>
								<tr>
								<td> pdir </td>
								<td>` + pdir + `</td>
								</tr>
								<tr>
								<td> pos </td>
								<td>` + strconv.Itoa(last) + `</td>
								</tr>
								<tr>
								<td> pdir-replaced </td>
								<td>` + strings.Replace(pdir, `\`, `\\`, -1) + `</td>
								</tr>
								<tr>
								<td> head </td>
								<td>` + head + `</td>
								</tr>
								<tr>
								<td> mode </td>
								<td>` + mode + `</td>
								</tr>
							  </table>`)

		this.Ctx.WriteString(`<div> nls:` + nls + `</div>`)
		this.Ctx.WriteString(`<div> batch:` + batch + `</div>`)
		this.Ctx.WriteString(`<div> mode:` + mode + `</div>`)
		this.Ctx.WriteString(`<div> dsn:` + dsn + `</div>`)
		this.Ctx.WriteString(`<div> qry:` + qry + `</div>`)
		this.Ctx.WriteString(`<div> del:` + del + `</div>`)
		this.Ctx.WriteString(`<div> dir:` + dir + `</div>`)
		this.Ctx.WriteString(`<div> pdir:` + pdir + `</div>`)
		this.Ctx.WriteString(`<div> idx:` + strconv.Itoa(last) + `</div>`)
	*/
	pdir = strings.Replace(pdir, `\`, `\\`, -1)
	//this.Ctx.WriteString(`<div> pdir-replaced:` + pdir + `</div>`)
	//this.Ctx.WriteString(`<div> head:` + head + `</div>`)

	//递归创建父目录
	err = os.MkdirAll(pdir, 0777)
	if err != nil {
		fmt.Printf("%s", err)
	} else {
		fmt.Println("Create Directory OK!")
	}

	// del = ".." //7F7F
	if err := dump2(nls, dir, pdir, finame, dsn, qry, del, head, mode, batch, ws); err != nil {
		log.Printf("error dumping: %s", err)
		this.Ctx.WriteString(err.Error())
	}

}
