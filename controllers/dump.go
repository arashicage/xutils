package controllers

import (
	"bufio"
	"fmt"
	"github.com/astaxie/beego"
	"github.com/astaxie/beego/logs"
	"github.com/juju/errgo/errors"
	"github.com/tgulacsi/goracle/examples/connect"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
)

type DumpController struct {
	beego.Controller
}

func dump(nls, dir, pdir, finame, dsn, qry, del, head, mode, batch string) error {

	//os.Setenv("NLS_LANG", nls)
	//如果文件不存在则创建文件，如果文件已经存则覆写文件
	w, err := os.OpenFile(dir, os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)
	if err != nil {
		fmt.Println("writer", err)
	}
	defer w.Close()

	cx, err := connect.GetRawConnection(dsn)
	if err != nil {
		return errors.Newf("error connecting to database: %s", err)
	}
	defer cx.Close()

	cu := cx.NewCursor()
	err = cu.Execute(qry, nil, nil)
	if err != nil {
		return errors.Newf("error executing %q: %s", qry, err)
	}
	defer cu.Close()

	columns, err := GetColumns(cu)
	if err != nil {
		return errors.Newf("error getting column converters: %s", err)
	}

	bw := bufio.NewWriterSize(w, 65536)
	defer bw.Flush()
	if head == "Y" {
		for i, col := range columns {
			if i > 0 {
				bw.WriteString(del)
			}
			bw.Write([]byte{'"'})
			bw.WriteString(col.Name)
			bw.Write([]byte{'"'})
		}
		bw.Write([]byte{'\n'})
	}

	n := 0                        // 记录数量
	fino := 1                     //文件编号
	filelist := make([]string, 0) //文件列表

	rows, err := cu.FetchMany(1000)
	for err == nil && len(rows) > 0 {
		for _, row := range rows {
			for i, data := range row {
				if i > 0 {
					bw.WriteString(del)
				}
				if data == nil {
					continue
				}
				bw.WriteString(columns[i].String(data))
			}
			bw.Write([]byte{'\n'})
			n++

			batchInt, _ := strconv.Atoi(batch)
			if n%batchInt == 0 {
				bw.Flush()
				w.Close() //如果文件到达批量写入点，显式flush

				w, err := os.OpenFile(dir+"."+strconv.Itoa(fino), os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)
				if err != nil {
					fmt.Println("writer", err)
				} else {
					filelist = append(filelist, dir+"."+strconv.Itoa(fino))
					fino++
				}
				defer w.Close()

				bw = bufio.NewWriterSize(w, 65536)
				defer bw.Flush()
			}
		}
		rows, err = cu.FetchMany(1000)
	}

	log.Printf("written %d rows.", n)
	if err != nil && err != io.EOF {
		return errors.Newf("error fetching rows from %s: %s", cu, err)
	}

	// 控制文件处理  导出的文本文件需要转换成 ansi/ascii 格式
	file, err := os.OpenFile(pdir+"\\sqlload.ctl", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)

	if err != nil {
		fmt.Println("创建控制文件失败", err)
	}
	defer file.Close()

	ctl :=
		`--
-- Generated by OCIULDR
--
OPTIONS(BINDSIZE=16777216,READSIZE=16777216,ERRORS=-1,ROWS=50000,PARALLEL=true)
LOAD DATA
infile '132000000\zzs_db_cgl.txt' "STR X'0a'" badfile '132000000\zzs_db_cgl.bad' discardfile '132000000\zzs_db_cgl.dis'
APPEND INTO TABLE zzs_db_cgl
FIELDS TERMINATED BY X'7e7e' TRAILING NULLCOLS 
(`

	fmt.Println(ctl)

	file.WriteString(`--` + "\r\n")
	file.WriteString(`-- Generated by X-SYSTEM` + "\r\n")
	file.WriteString(`--` + "\r\n")
	file.WriteString(`OPTIONS(BINDSIZE=16777216,READSIZE=16777216,ERRORS=-1,ROWS=50000,PARALLEL=true)` + "\r\n")
	file.WriteString(`LOAD DATA` + "\r\n")
	file.WriteString(`CHARACTERSET UTF8` + "\r\n")
	file.WriteString(`--LENGTH BYTE` + "\r\n")
	file.WriteString(`infile '` + finame + `' "STR X'0a'" badfile '` + finame + `.bad' discardfile '` + finame + `.dis'` + "\r\n")
	for i := 0; i < len(filelist); i++ {
		fmt.Println(filelist[i])
		fmt.Println(pdir)
		file.WriteString(`infile '` + SubStr(filelist[i], strings.LastIndex(filelist[i], `\`)+1, len(filelist[i])) + `' "STR X'0a'" badfile '` + SubStr(filelist[i], strings.LastIndex(filelist[i], `\`)+1, len(filelist[i])) + `.bad' discardfile '` + SubStr(filelist[i], strings.LastIndex(filelist[i], `\`)+1, len(filelist[i])) + `.dis'` + "\r\n")

	}
	file.WriteString(mode + ` INTO TABLE TABLE_NAME` + "\r\n")
	file.WriteString(`FIELDS TERMINATED BY X'7e7e' TRAILING NULLCOLS` + "\r\n")
	file.WriteString(`(` + "\r\n")

	desc, err := cu.GetDescription()
	for i, col := range desc {
		if i != len(desc)-1 {
			if col.Type == 156 { //date   DATE "YYYY-MM-DD HH24:MI:SS",
				fmt.Println(fmt.Sprintf("  %-32sDATE 'YYYY-MM-DD HH24:MI:SS',", col.Name))
				file.WriteString(fmt.Sprintf("  %-32sDATE 'YYYY-MM-DD HH24:MI:SS',\r\n", col.Name))
			} else {
				fmt.Printf("  %-32sCHAR(%d),\n", col.Name, col.InternalSize)
				file.WriteString(fmt.Sprintf("  %-32sCHAR(%d),\r\n", col.Name, col.InternalSize))
			}

		} else { //最后一个字段
			if col.Type == 156 {
				fmt.Println(fmt.Sprintf("  %-32sDATE 'YYYY-MM-DD HH24:MI:SS'", col.Name))
				file.WriteString(fmt.Sprintf("  %-32sDATE 'YYYY-MM-DD HH24:MI:SS'\r\n", col.Name))
			} else {
				fmt.Printf("  %-32sCHAR(%d)\n", col.Name, col.InternalSize)
				file.WriteString(fmt.Sprintf("  %-32sCHAR(%d)\r\n", col.Name, col.InternalSize))
			}
		}

	}
	fmt.Println(")")
	file.WriteString(")")

	// 批处理文件
	batFile, err := os.OpenFile(pdir+"\\sqlload.bat", os.O_WRONLY|os.O_TRUNC|os.O_CREATE, os.ModePerm)
	if err != nil {
		fmt.Println("创建批处理文件失败", err)
	}
	defer batFile.Close()

	batFile.WriteString(":: unloading parameters: \r\n")
	batFile.WriteString(":: DSN :  " + dsn + "\r\n")
	batFile.WriteString(":: SQL :  " + qry + "\r\n")
	batFile.WriteString(":: DEL :  " + del + "\r\n")
	batFile.WriteString(":: HEAD:  " + head + "\r\n")
	batFile.WriteString(":: MODE:  " + mode + "\r\n")
	batFile.WriteString(":: BATCH:  " + batch + "\r\n")
	batFile.WriteString("rem chcp 936\r\n")
	batFile.WriteString("rem set NLS_LANG=SIMPLIFIED CHINESE_CHINA.ZHS16GBK\r\n")
	batFile.WriteString("rem set NLS_LANG=AMERICAN AMERICA.US7ASCII\r\n")
	batFile.WriteString("sqlldr dzdz/oracle@tns_name control=sqlload.ctl log=sqlload.log\r\n")
	batFile.WriteString("pause")

	return nil
}

func (this *DumpController) Post() {
	this.Data["title"] = "导出 - X-Utils"
	logx := logs.NewLogger(10000)
	logx.SetLogger("console", "")
	nls := this.Input().Get("nls")
	dsn := this.Input().Get("dsn")
	qry := this.Input().Get("qry")
	dir := this.Input().Get("dir")
	del := this.Input().Get("del")
	batch := this.Input().Get("batch")
	mode := this.Input().Get("mode")
	head := this.Input().Get("head")

	//设置默认分隔符 ≡
	if del == "" {
		del = "~~" //使用 7F 容易在导入的时候产生bad 文件
	}

	last := strings.LastIndex(dir, `\`)
	pdir := SubStr(dir, 0, last) //获取父目录
	finame := SubStr(dir, last+1, len(dir))

	this.Ctx.WriteString(`<table border="1">
							<tr>
							<td> nls </td>
							<td>` + nls + `</td>
							</tr>
							<tr>
							<td> batch </td>
							<td>` + batch + `</td>
							</tr>
							<tr>
							<td> mode </td>
							<td>` + mode + `</td>
							</tr>
							<tr>
							<td> dsn </td>
							<td>` + dsn + `</td>
							</tr>
							<tr>
							<td> qry </td>
							<td>` + qry + `</td>
							</tr>
							<tr>
							<td> del </td>
							<td>` + del + `</td>
							</tr>
							<tr>
							<td> dir </td>
							<td>` + dir + `</td>
							</tr>
							<tr>
							<td> pdir </td>
							<td>` + pdir + `</td>
							</tr>
							<tr>
							<td> pos </td>
							<td>` + strconv.Itoa(last) + `</td>
							</tr>
							<tr>
							<td> pdir-replaced </td>
							<td>` + strings.Replace(pdir, `\`, `\\`, -1) + `</td>
							</tr>
							<tr>
							<td> head </td>
							<td>` + head + `</td>
							</tr>
							<tr>
							<td> mode </td>
							<td>` + mode + `</td>
							</tr>
						  </table>`)

	this.Ctx.WriteString(`<div> nls:` + nls + `</div>`)
	this.Ctx.WriteString(`<div> batch:` + batch + `</div>`)
	this.Ctx.WriteString(`<div> mode:` + mode + `</div>`)
	this.Ctx.WriteString(`<div> dsn:` + dsn + `</div>`)
	this.Ctx.WriteString(`<div> qry:` + qry + `</div>`)
	this.Ctx.WriteString(`<div> del:` + del + `</div>`)
	this.Ctx.WriteString(`<div> dir:` + dir + `</div>`)
	this.Ctx.WriteString(`<div> pdir:` + pdir + `</div>`)
	this.Ctx.WriteString(`<div> idx:` + strconv.Itoa(last) + `</div>`)

	pdir = strings.Replace(pdir, `\`, `\\`, -1)
	this.Ctx.WriteString(`<div> pdir-replaced:` + pdir + `</div>`)
	this.Ctx.WriteString(`<div> head:` + head + `</div>`)

	//递归创建父目录
	err := os.MkdirAll(pdir, 0777)
	if err != nil {
		fmt.Printf("%s", err)
	} else {
		fmt.Println("Create Directory OK!")
	}

	// del = ".." //7F7F
	if err := dump(nls, dir, pdir, finame, dsn, qry, del, head, mode, batch); err != nil {
		log.Printf("error dumping: %s", err)
		this.Ctx.WriteString(err.Error())
	}
	this.Ctx.WriteString(`<br/><a href="http://localhost:8080/utils">back</a>`)

}
